// Generated by FUECCode.verilog_decoder_module_rom
// Pipelined FUEC Decoder (48, 32) using a Block RAM ROM
// Latency: 3 clock cycles (1 for syndrome, 1 for ROM lookup, 1 for correction)
module fuec_decoder_48_32_rom (
    input  wire         clk,
    input  wire         rst,
   input  wire [47:0] r_in,
   output wire [15:0] s_out,
   output wire [47:0] r_fix_out,
   output wire [47:0] pos_error_out,
    output wire         no_error_out,
    output wire         corrected_out,
    output wire         uncorrectable_out
);

    // --- Pipeline Stage 1: Syndrome Calculation ---
   reg  [47:0] r_s1;
   wire [15:0] s_wire;

    // --- Pipeline Stage 2: ROM Lookup ---
   reg [47:0] r_s2;
   reg [15:0] s_s2; // Registered syndrome, used as ROM address
   wire [47:0] flip_bits_from_rom; // Output of the ROM

    // --- Pipeline Stage 3: Apply Correction & Status ---
   reg [47:0] r_s3;
   reg [47:0] flip_bits_s3;
   reg [15:0] s_s3;

    // Parity-check matrix rows for syndrome calculation
    localparam [47:0] HROW0 = 48'b000000000000000111100101001111101111111000010100;
    localparam [47:0] HROW1 = 48'b000000000000001001101110010000011000101001011110;
    localparam [47:0] HROW2 = 48'b000000000000010010110001100101110001110111000010;
    localparam [47:0] HROW3 = 48'b000000000000100000110001001001100011000101001101;
    localparam [47:0] HROW4 = 48'b000000000001000001010010100101100101101101100011;
    localparam [47:0] HROW5 = 48'b000000000010000001011100110101010111011000101010;
    localparam [47:0] HROW6 = 48'b000000000100000011111010111110100110111001101100;
    localparam [47:0] HROW7 = 48'b000000001000000001000101011000110010100110110101;
    localparam [47:0] HROW8 = 48'b000000010000000011010110011011101101111100101010;
    localparam [47:0] HROW9 = 48'b000000100000000010001000100100001011000110111101;
    localparam [47:0] HROW10 = 48'b000001000000000011110001101000111011011010001011;
    localparam [47:0] HROW11 = 48'b000010000000000010111100110110100101010110011100;
    localparam [47:0] HROW12 = 48'b000100000000000000100001011110011111001101101000;
    localparam [47:0] HROW13 = 48'b001000000000000001000111100110010000101010111000;
    localparam [47:0] HROW14 = 48'b010000000000000010010111011010110001110100100110;
    localparam [47:0] HROW15 = 48'b100000000000000001110101010010000100011010110110;

    assign s_wire[0] = ^(r_s1 & HROW0);
    assign s_wire[1] = ^(r_s1 & HROW1);
    assign s_wire[2] = ^(r_s1 & HROW2);
    assign s_wire[3] = ^(r_s1 & HROW3);
    assign s_wire[4] = ^(r_s1 & HROW4);
    assign s_wire[5] = ^(r_s1 & HROW5);
    assign s_wire[6] = ^(r_s1 & HROW6);
    assign s_wire[7] = ^(r_s1 & HROW7);
    assign s_wire[8] = ^(r_s1 & HROW8);
    assign s_wire[9] = ^(r_s1 & HROW9);
    assign s_wire[10] = ^(r_s1 & HROW10);
    assign s_wire[11] = ^(r_s1 & HROW11);
    assign s_wire[12] = ^(r_s1 & HROW12);
    assign s_wire[13] = ^(r_s1 & HROW13);
    assign s_wire[14] = ^(r_s1 & HROW14);
    assign s_wire[15] = ^(r_s1 & HROW15);

    // Instantiate the Block Memory Generator IP (ROM) here.
    // - Configure as a Single Port ROM
   // - Depth: 65536 (2^16)
   // - Width: 48
    // - Load the .coe file generated by the python script.
   ecc_rom_ip ecc_correction_rom (
        .clka(clk),
        .addra(s_s2),
        .douta(flip_bits_from_rom)
    );

    // Pipeline Register Logic
    always @(posedge clk) begin
        if (rst) begin
            r_s1 <= '0; r_s2 <= '0; r_s3 <= '0;
            s_s2 <= '0; s_s3 <= '0;
            flip_bits_s3 <= '0;
        end else begin
            // Stage 1 -> 2
            r_s1 <= r_in;
            s_s2 <= s_wire;

            // Stage 2 -> 3
            r_s2 <= r_s1;
            s_s3 <= s_s2;
            flip_bits_s3 <= flip_bits_from_rom;

            // Stage 3 -> Output Register (not strictly needed, but good practice)
            r_s3 <= r_s2;
        end
    end

    // Final Output Assignments (combinational from last pipeline stage)
    assign s_out = s_s3;
    assign pos_error_out = flip_bits_s3;
    assign r_fix_out = r_s3 ^ flip_bits_s3;

    // Status flags are based on the state in the final pipeline stage
    assign no_error_out = (s_s3 == 0);
    assign corrected_out = (|flip_bits_s3);
    assign uncorrectable_out = ((|s_s3) && !(|flip_bits_s3));

endmodule